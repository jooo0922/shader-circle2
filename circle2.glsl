#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

void main() {
  vec2 coord = gl_FragCoord.xy / u_resolution; // 각 픽셀들의 좌표값 정규화
  coord.x *= u_resolution.x / u_resolution.y; // 캔버스가 늘어날 때 화면 왜곡을 방지하도록 해상도 비율을 각 픽셀들의 st.x 좌표값에 곱해줌.

  // 캔버스의 원점을 좌하단 -> 캔버스 중앙으로 옮겨질 수 있게 각 픽셀들의 좌표값들을 변경함(지난 번 예제에서 다뤘던 내용)
  // 캔버스로 치면 translate에 해당하는 기능을 구현한 것.  
  coord = coord * 2. - 1.;

  // 방사형 원이 사분면에 나뉘어서 그려져있는데, 이 때, 1사분면의 원의 중심점 좌표를 대략 (0.3, 0.3) 정도로 할당한 것.
  vec2 point = vec2(.3);

  // 각 픽셀들과 1사분면 원 중심점 사이의 거리를 계산한 것.
  // 이 때, 우리는 사분면 각각에 방사형 원을 그리고 싶은데 어떻게 할 수 있을까?
  // 일단, 1사분면은 x, y 좌표값이 모두 양수이지만, 다른 사분면들은 두 좌표값 중 적어도 하나는 음수잖아.
  // 이 때, 1사분면을 제외한 나머지 사분면들에 존재하는 픽셀들의 x, y 좌표값을 abs() 내장함수를 이용하여
  // 절댓값으로 변화하면, 1사분면과 동일한, 1사분면과 Mapping되는 좌표값을 얻을 수 있게 됨.
  // 그렇다면, 이 Mapping되는 좌표값을 이용해서 구한 거리값, 또 그 거리값으로 구한 각 픽셀들의 색상값은
  // 1사분면의 각 대응되는 좌표값을 갖는 픽셀들과 동일한 색상값을 가지겠지?
  // 그래서 각 사분면이 1사분면과 대칭되는 방사형 그라데이션을 찍어볼 수 있게 됨
  float d = distance(abs(coord), point);

  // 근데 이제 방사형 그라데이션이 어떤 경계지점에서 끝나고 다시 새로운 그라데이션을 그리는
  // 경계를 가진 방사형 원들을 그리려면 어떻게 해야할까?
  // 이럴 경우, 각 사분면의 원 중심과의 거리값인 d값을 mod() 내장함수로 나머지 계산을 해주면 됨.
  // 아래와 같이 0.1로 d를 나눈 나머지를 리턴받아 d에 갱신을 하게 되면,
  // d값은 각 사분면에서 픽셀들이 원 중심에서 멀어질수록 0 ~ 0.1 사이의 값을 주기적으로 반복해서 리턴받게 됨.
  // 즉, d값이 0 ~ 0.1 -> 0 ~ 0.1 -> 0 ~ 0.1 이렇게 리턴받게 된다는 거임.
  // 그에 따라 색상값도 저 주기를 갖게 되고, 0.1을 나머지로 받고 나서 다음 주기의 나머지로 0을 받는 지점에서
  // 방사형 원의 경계가 그려지게 되는 것이지! 
  // d = mod(d, .1);  // 그런데 이럴 경우, 가장 밝은 색상값이 (0.1, 0.1, 0.1)이기 때문에 경계의 명암대비가 뚜렷하지 못함.

  // 따라서, 1.0으로 나눠서 나머지 리턴값 주기를 0 ~ 1로 바꿔주면 가장 밝은 색상값을 (1.0, 1.0, 1.0) 즉, white까지 찍어볼 수 있겠지
  // 그런데, d값을 1.0 으로 나누니까 d값(즉, 사분면 원점에서 픽셀 사이의 거리값)이 워낙 작아서 그런지
  // 나머지 리턴값이 0 에서 1로 도달하려면(즉, white를 찍으려면) d값이 꽤 멀리까지 나가야 되다보니 방사형 원 느낌이 안듦.
  // 따라서, 이를 수정하기 위해 d값을 10배로 곱하면 1로 나눴을 때 금방금방 나머지 리턴값이 1에 도달할 수 있겠지
  // d = mod(d * 10., 1.); 

  // mod(나눠지는 값, 나눠주는 값)과 비슷한 역할을 하는 내장함수 fract(나눠지는 값) 을 이용해서 그릴 수도 있음.
  // fract(x) 함수는 x의 소수점 부분(즉, fractional number)만 리턴해주는 내장함수이므로,
  // 인자로 전달된 x값을 1로 나눈 나머지를 리턴해준다고 봐도 무방함.
  // 얘도 마찬가지로 d값만 인자로 전달하면 d가 너무 작은 값들이기 때문에
  // 나머지 리턴값이 1에 가까운 값이 되기 위해 상당히 멀리까지 가야 함.
  // 따라서 나머지 리턴값이 더 빨리 1에 도달하기 위해 mod() 에서 했던 것처럼 d값에 10을 곱해줌.
  d = fract(d * 10.); // 이 곱해주는 값이 더 커질수록 나머지 리턴값이 1에 더 빨리 도달할테니, 방사형 원의 물결이 더 촘촘해질거임

  // 일단 1사분면의 원 중심점과 각 픽셀들 사이의 거리값에 따라 색상값을 매겨줘서 그라데이션을 찍어봄
  vec3 col = vec3(d);

  gl_FragColor = vec4(col, 1.);
}

/*
  이번 예제에서는 원문코드로 방사형 원을 그리는 게 중요한 게 아니라, 

  st.x *= u_resolution.x / u_resolution.y;

  이 11번째 줄의 코드를 새롭게 배운다는 것에 의미가 있음.
  만약 화면비율이 1:1인 정사각형 캔버스라면, 저 코드는 써주던 안써주던 아무런 의미가 없음.

  그러나, 만약 화면비율이 1:1이 아닌 경우라면,
  저 코드를 주석처리 할 시 방사형 원이 캔버스 화면 비율에 따라 늘어나고(찌그러들고) 왜곡되는 것을 볼 수 있음.

  그런데, 만약 내가 화면 비율과 상관 없이
  내가 그리는 도형의 가로 세로 비율이 영향받지 않고 싶다면
  저 11번째 줄 코드를 반드시 써줘야 함.


  이 코드의 원리를 좀 더 자셓 파악해보자.
  10번째 줄에 의해 각 픽셀들의 좌표값은 0 ~ 1 사이의 값으로 normalize가 되겠지.

  그러나, 만약 화면이 가로로 늘어난 상태가 된다면,
  각 단위 픽셀들의 가로 길이가 사실상 더 길 수밖에 없겠지.
  왜냐면 전체 화면이 가로로 더 기니까

  이거는 세로로 늘어난 경우에도 마찬가지로 단위 픽셀들의 세로 길이가 더 길 것이고.

  이렇게 단위 픽셀의 한쪽 길이가 늘어나서 전체적으로 찌그러져 보이는 걸 막기 위해
  11번째 코드를 작성한 것임.

  수학적 원리를 설명하자면,
  u_resolution.x / u_resolution.y 값은
  화면이 가로로 더 길다면 1보다 더 큰 수치가 나타나겠지. 1.~~~ 요런 식으로
  반대로 세로로 더 길면 0.~~~ 뭐 이렇게 나오겠지

  이런 식으로
  화면이 가로로 더 길다면 저 값은 1보다 큰 값이 나올 것이고,
  화면이 세로로 더 길다면 저 값은 0 ~ 1 사이의, 1보다 작은 값이 나올 것임.

  이렇게 화면 비율에 따라서 '화면 가로 길이 / 화면 세로 길이' 로 나눈 비율을
  st.x(정규화된 픽셀의 x좌표값)에 곱해줌으로써
  화면 해상도 변화에 따라서 단위 픽셀 당 담아야 하는 실제 가로 길이를 조정해주는 것!
  -> 이렇게 하면 해상도와 상관없이 도형의 비율이 망가지지 않도록 하는 것.


  이게 화면이 늘어나고 왜곡되는 상황이
  캔버스로 치면 캔버스의 픽셀 개수는 그대로인데 
  한쪽의 css size가 늘어나는 것과 동일한 현상이 발생하는 거임.

  그래서 캔버스 프로젝트에서는 (three.js 프로젝트도 마찬가지로)
  늘어난 css size에 맞게 캔버스 픽셀 개수도 동일하게 변경해주면
  화면을 늘이거나 줄여도 별다른 왜곡없이 렌더링됬었음.

  그러나 셰이더에서는 캔버스 픽셀 개수를 할당할 수 없으니
  위와 같이 해상도 비율을 각 픽셀들의 좌표값에 곱해줘서  
  렌더링되는 도형의 왜곡을 방지하는 것 같음.


  어쨋든, 셰이더에서는 위와 같은 방식으로 해상도를 맞춰주고 있으므로,
  앞으로 셰이더 작성 시 default 코드에 저 해상도 맞춰주는 코드도 추가해줄 것
*/